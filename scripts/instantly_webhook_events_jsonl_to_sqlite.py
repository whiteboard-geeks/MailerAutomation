"""Convert Instantly webhook events from JSONL format to SQLite database.

Usage:

    python -m scripts.instantly_webhook_events_jsonl_to_sqlite <jsonl_file> <output_db>

The script reads jsonl files generated by the script `instantly_get_webhook_events.py`
and stores them in a SQLite database.
"""

from __future__ import annotations

import argparse
import json
import sqlite3
import sys
from pathlib import Path
from typing import Any, Iterable, Sequence


TABLE_NAME = "events"


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Convert Instantly webhook events JSONL into a SQLite database."
    )
    parser.add_argument("jsonl_file", help="Path to the source JSONL file")
    parser.add_argument("output_db", help="Path to the destination SQLite database")
    return parser.parse_args(argv)


def load_jsonl(path: Path) -> list[dict[str, Any]]:
    records: list[dict[str, Any]] = []

    with path.open("r", encoding="utf-8") as handle:
        for line_number, raw_line in enumerate(handle, start=1):
            line = raw_line.strip()
            if not line:
                continue

            try:
                payload = json.loads(line)
            except json.JSONDecodeError as exc:  # pragma: no cover - defensive
                raise ValueError(
                    f"Failed to parse JSON on line {line_number}: {exc}"
                ) from exc

            if not isinstance(payload, dict):
                raise ValueError(
                    f"JSON entry on line {line_number} is not an object: {payload!r}"
                )

            records.append(payload)

    return records


def detect_column_types(records: Iterable[dict[str, Any]]) -> dict[str, str]:
    columns: set[str] = set()
    for record in records:
        columns.update(record.keys())

    if not columns:
        raise ValueError("No columns detected in the provided JSONL data.")

    type_hints: dict[str, set[str]] = {column: set() for column in columns}

    for record in records:
        for column, value in record.items():
            inferred = infer_value_kind(value)
            if inferred:
                type_hints[column].add(inferred)

    return {column: decide_sqlite_type(type_hints[column]) for column in columns}


def infer_value_kind(value: Any) -> str | None:
    if value is None:
        return None
    if isinstance(value, bool):
        return "bool"
    if isinstance(value, int):
        return "int"
    if isinstance(value, float):
        return "float"
    if isinstance(value, str):
        return "str"
    return "json"


def decide_sqlite_type(kinds: set[str]) -> str:
    if not kinds:
        return "TEXT"
    if kinds <= {"bool", "int"}:
        return "INTEGER"
    if kinds <= {"bool", "int", "float"} and "float" in kinds:
        return "REAL"
    if kinds == {"int"}:
        return "INTEGER"
    if kinds == {"float"}:
        return "REAL"
    return "TEXT"


def sanitize_value(value: Any, column_type: str) -> Any:
    if value is None:
        return None

    if column_type == "INTEGER":
        if isinstance(value, bool):
            return int(value)
        if isinstance(value, (int,)):
            return value
        if isinstance(value, (float,)):
            return int(value)
        return int(str(value))

    if column_type == "REAL":
        if isinstance(value, (int, float)):
            return float(value)
        return float(str(value))

    if isinstance(value, (dict, list)):
        return json.dumps(value, ensure_ascii=False)

    return str(value)


def quote_identifier(identifier: str) -> str:
    escaped = identifier.replace("\"", "\"\"")
    return f'"{escaped}"'


def create_table(conn: sqlite3.Connection, schema: dict[str, str]) -> None:
    columns_sql = ", ".join(
        f"{quote_identifier(column)} {column_type}" for column, column_type in sorted(schema.items())
    )
    conn.execute(f"CREATE TABLE {quote_identifier(TABLE_NAME)} ({columns_sql})")


def insert_records(
    conn: sqlite3.Connection,
    records: Iterable[dict[str, Any]],
    schema: dict[str, str],
) -> None:
    ordered_columns = [column for column, _ in sorted(schema.items())]
    placeholders = ",".join(["?"] * len(ordered_columns))
    insert_sql = (
        f"INSERT INTO {quote_identifier(TABLE_NAME)}"
        f" ({', '.join(quote_identifier(column) for column in ordered_columns)})"
        f" VALUES ({placeholders})"
    )

    rows = (
        tuple(
            sanitize_value(record.get(column), schema[column])
            for column in ordered_columns
        )
        for record in records
    )

    conn.executemany(insert_sql, rows)


def convert(jsonl_path: Path, output_path: Path) -> None:
    records = load_jsonl(jsonl_path)
    if not records:
        raise ValueError("Input JSONL file does not contain any records.")

    schema = detect_column_types(records)

    if output_path.exists():
        output_path.unlink()
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with sqlite3.connect(output_path) as conn:
        create_table(conn, schema)
        insert_records(conn, records, schema)
        conn.commit()


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)
    jsonl_path = Path(args.jsonl_file)
    output_path = Path(args.output_db)

    if not jsonl_path.exists():
        print(f"Input file not found: {jsonl_path}", file=sys.stderr)
        return 1

    try:
        convert(jsonl_path, output_path)
    except ValueError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    print(f"Converted {jsonl_path} -> {output_path}")
    return 0


if __name__ == "__main__":  # pragma: no cover - script entry point
    sys.exit(main())
